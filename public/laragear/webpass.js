var Webpass=function(){"use strict";function e(e){const t=new Uint8Array(e);let n="";for(const e of t)n+=String.fromCharCode(e);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function t(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,r=t.padEnd(t.length+n,"="),o=atob(r),s=new ArrayBuffer(o.length),a=new Uint8Array(s);for(let e=0;e<o.length;e++)a[e]=o.charCodeAt(e);return s}function n(){return void 0!==window?.PublicKeyCredential&&"function"==typeof window.PublicKeyCredential}function r(e){const{id:n}=e;return{...e,id:t(n),transports:e.transports}}function o(e){return"localhost"===e||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class s extends Error{constructor({message:e,code:t,cause:n,name:r}){super(e,{cause:n}),this.name=r??n.name,this.code=t}}const a=new class{createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}},i=["cross-platform","platform"];function c(e){if(e&&!(i.indexOf(e)<0))return e}async function u(i){if(!n())throw new Error("WebAuthn is not supported in this browser");const u={publicKey:{...i,challenge:t(i.challenge),user:{...i.user,id:t(i.user.id)},excludeCredentials:i.excludeCredentials?.map(r)}};let p;u.signal=a.createNewAbortSignal();try{p=await navigator.credentials.create(u)}catch(e){throw function({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if("AbortError"===e.name){if(t.signal instanceof AbortSignal)return new s({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if("ConstraintError"===e.name){if(!0===n.authenticatorSelection?.requireResidentKey)return new s({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if("required"===n.authenticatorSelection?.userVerification)return new s({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if("InvalidStateError"===e.name)return new s({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if("NotAllowedError"===e.name)return new s({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if("NotSupportedError"===e.name)return 0===n.pubKeyCredParams.filter((e=>"public-key"===e.type)).length?new s({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new s({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if("SecurityError"===e.name){const t=window.location.hostname;if(!o(t))return new s({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(n.rp.id!==t)return new s({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if("TypeError"===e.name){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new s({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if("UnknownError"===e.name)return new s({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}({error:e,options:u})}if(!p)throw new Error("Registration was not completed");const{id:d,rawId:f,response:h,type:w}=p;let y,m,b,g;if("function"==typeof h.getTransports&&(y=h.getTransports()),"function"==typeof h.getPublicKeyAlgorithm)try{m=h.getPublicKeyAlgorithm()}catch(e){l("getPublicKeyAlgorithm()",e)}if("function"==typeof h.getPublicKey)try{const t=h.getPublicKey();null!==t&&(b=e(t))}catch(e){l("getPublicKey()",e)}if("function"==typeof h.getAuthenticatorData)try{g=e(h.getAuthenticatorData())}catch(e){l("getAuthenticatorData()",e)}return{id:d,rawId:e(f),response:{attestationObject:e(h.attestationObject),clientDataJSON:e(h.clientDataJSON),transports:y,publicKeyAlgorithm:m,publicKey:b,authenticatorData:g},type:w,clientExtensionResults:p.getClientExtensionResults(),authenticatorAttachment:c(p.authenticatorAttachment)}}function l(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.\n`,t)}function p(){if(!n())return new Promise((e=>e(!1)));const e=window.PublicKeyCredential;return void 0===e.isConditionalMediationAvailable?new Promise((e=>e(!1))):e.isConditionalMediationAvailable()}async function d(i,u=!1){if(!n())throw new Error("WebAuthn is not supported in this browser");let l;0!==i.allowCredentials?.length&&(l=i.allowCredentials?.map(r));const d={...i,challenge:t(i.challenge),allowCredentials:l},f={};if(u){if(!await p())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');f.mediation="conditional",d.allowCredentials=[]}let h;f.publicKey=d,f.signal=a.createNewAbortSignal();try{h=await navigator.credentials.get(f)}catch(e){throw function({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if("AbortError"===e.name){if(t.signal instanceof AbortSignal)return new s({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if("NotAllowedError"===e.name)return new s({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if("SecurityError"===e.name){const t=window.location.hostname;if(!o(t))return new s({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(n.rpId!==t)return new s({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if("UnknownError"===e.name)return new s({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}({error:e,options:f})}if(!h)throw new Error("Authentication was not completed");const{id:w,rawId:y,response:m,type:b}=h;let g;return m.userHandle&&(g=e(m.userHandle)),{id:w,rawId:e(y),response:{authenticatorData:e(m.authenticatorData),clientDataJSON:e(m.clientDataJSON),signature:e(m.signature),userHandle:g},type:b,clientExtensionResults:h.getClientExtensionResults(),authenticatorAttachment:c(h.authenticatorAttachment)}}function f(){return n()}async function h(){return f()&&await p()}async function w(){return f()&&await(n()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise((e=>e(!1))))}function y(e,t){const n=e[t];return delete e[t],n}function m(e){return"object"==typeof e&&!Object.keys(e).length}function b(e,t){if(!g(e))return b({},t);const n=Object.assign({},e);return g(t)&&Object.keys(t).forEach((r=>{g(t[r])?r in e?n[r]=b(e[r],t[r]):Object.assign(n,{[r]:t[r]}):Object.assign(n,{[r]:t[r]})})),n}function g(e){return null!==e&&!Array.isArray(e)&&"object"==typeof e&&"function"!=typeof e}function R(e,t,n){return e||(e=t.routes[n]),"string"==typeof e&&(e={path:e}),e.path=e.path||t.routes[n],e.baseURL=e.baseURL||t.baseURL||window.location.origin,e.body=e.body||{},e.method=e.method||t.method,e.headers=e.headers||t.headers,e.redirect=e.redirect||t.redirect,e.credentials=e.credentials||t.credentials,e}var E={method:"post",redirect:"error",baseURL:void 0,findCsrfToken:!1,findXsrfToken:!1,useAutofill:void 0,routes:{attestOptions:"/auth/attest-options",attest:"/auth/attest",assertOptions:"/auth/assert-options",assert:"/auth/assert"},headers:{Accept:"application/json","Content-Type":"application/json","X-Requested-With":"XMLHttpRequest"},credentials:"same-origin"};const A=/"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,T=/"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,O=/^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;function _(e,t){if(!("__proto__"===e||"constructor"===e&&t&&"object"==typeof t&&"prototype"in t))return t;!function(e){console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)}(e)}function C(e,t={}){if("string"!=typeof e)return e;const n=e.trim();if('"'===e[0]&&'"'===e.at(-1)&&!e.includes("\\"))return n.slice(1,-1);if(n.length<=9){const e=n.toLowerCase();if("true"===e)return!0;if("false"===e)return!1;if("undefined"===e)return;if("null"===e)return null;if("nan"===e)return Number.NaN;if("infinity"===e)return Number.POSITIVE_INFINITY;if("-infinity"===e)return Number.NEGATIVE_INFINITY}if(!O.test(e)){if(t.strict)throw new SyntaxError("[destr] Invalid JSON");return e}try{if(A.test(e)||T.test(e)){if(t.strict)throw new Error("[destr] Possible prototype pollution");return JSON.parse(e,_)}return JSON.parse(e)}catch(n){if(t.strict)throw n;return e}}const v=/#/g,S=/&/g,N=/=/g,I=/\+/g,P=/%5e/gi,D=/%60/gi,j=/%7c/gi,U=/%20/gi;function k(e){return(t="string"==typeof e?e:JSON.stringify(e),encodeURI(""+t).replace(j,"|")).replace(I,"%2B").replace(U,"+").replace(v,"%23").replace(S,"%26").replace(D,"`").replace(P,"^");var t}function q(e){return k(e).replace(N,"%3D")}function x(e=""){try{return decodeURIComponent(""+e)}catch{return""+e}}function L(e){return x(e.replace(I," "))}function K(e=""){const t={};"?"===e[0]&&(e=e.slice(1));for(const n of e.split("&")){const e=n.match(/([^=]+)=?(.*)/)||[];if(e.length<2)continue;const r=x(e[1].replace(I," "));if("__proto__"===r||"constructor"===r)continue;const o=L(e[2]||"");void 0===t[r]?t[r]=o:Array.isArray(t[r])?t[r].push(o):t[r]=[t[r],o]}return t}function $(e){return Object.keys(e).filter((t=>void 0!==e[t])).map((t=>{return n=t,"number"!=typeof(r=e[t])&&"boolean"!=typeof r||(r=String(r)),r?Array.isArray(r)?r.map((e=>`${q(n)}=${k(e)}`)).join("&"):`${q(n)}=${k(r)}`:q(n);var n,r})).filter(Boolean).join("&")}const H=/^[\s\w\0+.-]{2,}:([/\\]{1,2})/,F=/^[\s\w\0+.-]{2,}:([/\\]{2})?/,M=/^([/\\]\s*){2,}[^/\\]/;function W(e,t={}){return"boolean"==typeof t&&(t={acceptRelative:t}),t.strict?H.test(e):F.test(e)||!!t.acceptRelative&&M.test(e)}const G=/\/$|\/\?|\/#/;function V(e="",t){return t?G.test(e):e.endsWith("/")}function B(e="",t){if(!t)return e.endsWith("/")?e:e+"/";if(V(e,!0))return e||"/";let n=e,r="";const o=e.indexOf("#");if(o>=0&&(n=e.slice(0,o),r=e.slice(o),!n))return r;const[s,...a]=n.split("?");return s+"/"+(a.length>0?`?${a.join("?")}`:"")+r}function J(e,t){if(!(n=t)||"/"===n||W(e))return e;var n;const r=function(e="",t){if(!t)return(V(e)?e.slice(0,-1):e)||"/";if(!V(e,!0))return e||"/";let n=e,r="";const o=e.indexOf("#");o>=0&&(n=e.slice(0,o),r=e.slice(o));const[s,...a]=n.split("?");return(s.slice(0,-1)||"/")+(a.length>0?`?${a.join("?")}`:"")+r}(t);return e.startsWith(r)?e:function(e,...t){let n=e||"";for(const e of t.filter((e=>function(e){return e&&"/"!==e}(e))))if(n){const t=e.replace(X,"");n=B(n)+t}else n=e;return n}(r,e)}function Y(e,t){const n=z(e),r={...K(n.search),...t};return n.search=$(r),function(e){const t=e.pathname||"",n=e.search?(e.search.startsWith("?")?"":"?")+e.search:"",r=e.hash||"",o=e.auth?e.auth+"@":"",s=e.host||"",a=e.protocol?e.protocol+"//":"";return a+o+s+t+n+r}(n)}const X=/^\.?\//;function z(e="",t){const n=e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);if(n){const[,e,t=""]=n;return{protocol:e.toLowerCase(),pathname:t,href:e+t,auth:"",host:"",search:"",hash:""}}if(!W(e,{acceptRelative:!0}))return t?z(t+e):Z(e);const[,r="",o,s=""]=e.replace(/\\/g,"/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/)||[],[,a="",i=""]=s.match(/([^#/?]*)(.*)?/)||[],{pathname:c,search:u,hash:l}=Z(i.replace(/\/(?=[A-Za-z]:)/,""));return{protocol:r.toLowerCase(),auth:o?o.slice(0,Math.max(0,o.length-1)):"",host:a,pathname:c,search:u,hash:l}}function Z(e=""){const[t="",n="",r=""]=(e.match(/([^#?]*)(\?[^#]*)?(#.*)?/)||[]).splice(1);return{pathname:t,search:n,hash:r}}class Q extends Error{constructor(e,t){super(e,t),this.name="FetchError",t?.cause&&!this.cause&&(this.cause=t.cause)}}const ee=new Set(Object.freeze(["PATCH","POST","PUT","DELETE"]));function te(e="GET"){return ee.has(e.toUpperCase())}const ne=new Set(["image/svg","application/xml","application/xhtml","application/html"]),re=/^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;function oe(e,t,n=globalThis.Headers){const r={...t,...e};if(t?.params&&e?.params&&(r.params={...t?.params,...e?.params}),t?.query&&e?.query&&(r.query={...t?.query,...e?.query}),t?.headers&&e?.headers){r.headers=new n(t?.headers||{});for(const[t,o]of new n(e?.headers||{}))r.headers.set(t,o)}return r}const se=new Set([408,409,425,429,500,502,503,504]),ae=new Set([101,204,205,304]);const ie=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}(),ce=function e(t={}){const{fetch:n=globalThis.fetch,Headers:r=globalThis.Headers,AbortController:o=globalThis.AbortController}=t;async function s(e){const t=e.error&&"AbortError"===e.error.name&&!e.options.timeout||!1;if(!1!==e.options.retry&&!t){let t;t="number"==typeof e.options.retry?e.options.retry:te(e.options.method)?0:1;const n=e.response&&e.response.status||500;if(t>0&&(Array.isArray(e.options.retryStatusCodes)?e.options.retryStatusCodes.includes(n):se.has(n))){const n=e.options.retryDelay||0;return n>0&&await new Promise((e=>setTimeout(e,n))),a(e.request,{...e.options,retry:t-1,timeout:e.options.timeout})}}const n=function(e){const t=e.error?.message||e.error?.toString()||"",n=e.request?.method||e.options?.method||"GET",r=e.request?.url||String(e.request)||"/",o=`[${n}] ${JSON.stringify(r)}`,s=e.response?`${e.response.status} ${e.response.statusText}`:"<no response>",a=new Q(`${o}: ${s}${t?` ${t}`:""}`,e.error?{cause:e.error}:void 0);for(const t of["request","options","response"])Object.defineProperty(a,t,{get:()=>e[t]});for(const[t,n]of[["data","_data"],["status","status"],["statusCode","status"],["statusText","statusText"],["statusMessage","statusText"]])Object.defineProperty(a,t,{get:()=>e.response&&e.response[n]});return a}(e);throw Error.captureStackTrace&&Error.captureStackTrace(n,a),n}const a=async function(e,a={}){const i={request:e,options:oe(a,t.defaults,r),response:void 0,error:void 0};if(i.options.method=i.options.method?.toUpperCase(),i.options.onRequest&&await i.options.onRequest(i),"string"==typeof i.request&&(i.options.baseURL&&(i.request=J(i.request,i.options.baseURL)),(i.options.query||i.options.params)&&(i.request=Y(i.request,{...i.options.params,...i.options.query}))),i.options.body&&te(i.options.method)&&(!function(e){if(void 0===e)return!1;const t=typeof e;return"string"===t||"number"===t||"boolean"===t||null===t||"object"===t&&(!!Array.isArray(e)||!e.buffer&&(e.constructor&&"Object"===e.constructor.name||"function"==typeof e.toJSON))}(i.options.body)?("pipeTo"in i.options.body&&"function"==typeof i.options.body.pipeTo||"function"==typeof i.options.body.pipe)&&("duplex"in i.options||(i.options.duplex="half")):(i.options.body="string"==typeof i.options.body?i.options.body:JSON.stringify(i.options.body),i.options.headers=new r(i.options.headers||{}),i.options.headers.has("content-type")||i.options.headers.set("content-type","application/json"),i.options.headers.has("accept")||i.options.headers.set("accept","application/json"))),!i.options.signal&&i.options.timeout){const e=new o;setTimeout((()=>e.abort()),i.options.timeout),i.options.signal=e.signal}try{i.response=await n(i.request,i.options)}catch(e){return i.error=e,i.options.onRequestError&&await i.options.onRequestError(i),await s(i)}if(i.response.body&&!ae.has(i.response.status)&&"HEAD"!==i.options.method){const e=(i.options.parseResponse?"json":i.options.responseType)||function(e=""){if(!e)return"json";const t=e.split(";").shift()||"";return re.test(t)?"json":ne.has(t)||t.startsWith("text/")?"text":"blob"}(i.response.headers.get("content-type")||"");switch(e){case"json":{const e=await i.response.text(),t=i.options.parseResponse||C;i.response._data=t(e);break}case"stream":i.response._data=i.response.body;break;default:i.response._data=await i.response[e]()}}return i.options.onResponse&&await i.options.onResponse(i),!i.options.ignoreResponseError&&i.response.status>=400&&i.response.status<600?(i.options.onResponseError&&await i.options.onResponseError(i),await s(i)):i.response},i=async function(e,t){return(await a(e,t))._data};return i.raw=a,i.native=(...e)=>n(...e),i.create=(n={})=>e({...t,defaults:{...t.defaults,...n}}),i}({fetch:ie.fetch||(()=>Promise.reject(new Error("[ofetch] global.fetch is not supported!"))),Headers:ie.Headers,AbortController:ie.AbortController});function ue(e,t){!0===e&&function(e){return!Object.keys(e).find((t=>["x-csrf-token","x-xsrf-token"].includes(t.toLowerCase())&&!!e[t]))}(t)&&(e=Array.from(document.head.getElementsByTagName("meta")).find((e=>"csrf-token"===e.name.toLowerCase()&&!!e.content))?.content??Array.from(document.body.getElementsByTagName("input")).find((e=>"_token"===e.name.toLowerCase()&&"hidden"===e.type.toLowerCase()&&!!e.value))?.value??function(){const e=document.cookie.match(new RegExp("(^|;\\s*)([CX]SRF-TOKEN)=([^;]*)","i"));return e?decodeURIComponent(e[3]):void 0}()??""),"string"==typeof e&&(t[function(e){if(e.length<40){const e=new Error("The token must be an CSRF (40 characters) or XSRF token.");throw e.name="InvalidToken",e}return 40===e.length}(e)?"X-CSRF-TOKEN":"X-XSRF-TOKEN"]=e)}var le=async(e,t={})=>{const{path:n,...r}=e;return r.headers=r.headers||{},ue(function(e){return y(e,"findCsrfToken")||y(e,"findXsrfToken")}(e),r.headers),r.body=b(r.body??{},t),await ce(n,r)},pe=()=>{const e=new Date;return{start:e,stop:()=>{const t=(new Date).getTime()-e.getTime(),n=Math.floor(t/6e4),r=Number((t%6e4/1e3).toFixed(0));return(n?n+" minutes, ":"")+(r?r+" seconds.":"")}}};function de(e,t,n=void 0){const r=new Error(t);return r.name=e,r.cause=n,r}function fe(e={}){const t=b(structuredClone(E),e);async function n(e,n){const r=pe(),o=R(e,t,"attestOptions"),s=R(n,t,"attest"),a=await le(o);if(console.debug("Attestation Options Received",a),!a||m(a))throw de("InvalidAttestationResponse","The server responded with invalid or empty credential creation options.");let i;try{i=await u(a)}catch(e){throw de("AttestationCancelled","The credentials creation was not completed.",e)}console.debug("Attestation Credentials Created",i);const c=await le(s,i);return console.debug("Attestation benchmark",r.stop()),c}async function r(e,n){const r=pe(),o=R(e,t,"assertOptions"),s=R(n,t,"assert"),a=await le(o);if(console.debug("Assertion Options Received",a),!a||m(a))throw de("InvalidAssertionResponse","The server responded with invalid or empty credential request options.");let i;try{i=await d(a,o.useAutofill??s.useAutofill??t.useAutofill)}catch(e){throw de("AssertionCancelled","The credentials request was not completed.",e)}console.debug("Assertion Credentials Retrieved",i);const c=await le(s,i);return console.debug("Assertion benchmark",r.stop()),c}return{assert:async function(e,t){const n={data:void 0,user:void 0,token:void 0,success:!1,error:void 0};try{n.data=await r(e,t)}catch(e){return{...n,error:e}}finally{n.success=void 0===n.error}return"object"==typeof n.data?(n.user="object"==typeof n.data.user?n.data.user:n.data,n.token=n.data?.token||n.data?.jwt,n.token||"object"!=typeof n.user||(n.token=n.user?.token||n.user?.jwt)):"string"==typeof n.data&&(n.token=n.data),n},attest:async function(e,t){const r={data:void 0,credentials:void 0,id:void 0,success:!1,error:void 0};try{r.data=r.credentials=await n(e,t)}catch(e){return{...r,error:e}}finally{r.success=void 0===r.error}return"object"==typeof r.data&&(r.id=r.data?.id||r.data?.uuid),r},assertRaw:r,attestRaw:n}}return{create:fe,attest:async(e,t)=>await fe().attest(e,t),assert:async(e,t)=>await fe().assert(e,t),attestRaw:async(e,t)=>await fe().attestRaw(e,t),assertRaw:async(e,t)=>await fe().assertRaw(e,t),isSupported:f,isNotSupported:function(){return!f()},isUnsupported:function(){return!f()},isAutofillable:h,isNotAutofillable:async function(){return!await h()},isPlatformAuthenticator:w,isNotPlatformAuthenticator:async function(){return!await w()}}}();
